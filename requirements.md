X-Auth-Token: **** - токен авторизации для API

Project Requirements

Project Overview

Мы строим бот-колонию муравьёв для пошаговой стратегии DatsPulse.
Основные задачи:

Максимально набрать калорийность (яблоки 10 ккал, хлеб 20 ккал, нектар 60 ккал) 
Одновременно минимизировать потери юнитов и суммарный путь, т. к. эти показатели служат тай-брейками 
.
Всё делать в условиях частичной видимости (фог), гексаго­нальной карты и лимита 3 RPS 
.
Сервис состоит из трёх модулей:

Модуль	Функция
Core AI	Принимает решения, рассылает /api/move
Game Gateway	Общается с внешним API: /api/register → poll /api/arena → /api/move, соблюдая 3 RPS
UI + DB	Hex-карта слева, лог запросов справа, кнопки «Run / Pause», ручные команды; SQLite хранит мир, логи, параметры стратегии
Business Logic

Алгоритм победы
Этап	Ключевая логика
0. Регистрация	POST /api/register (token, имя). Сохраняем teamId, home (3 гекса), spot (центр).
1. Спавн-менеджмент	Муравей автоматически создаётся каждый ход в spot (тип выбирает сервер случайно; если в spot стоит муравей того же типа — спавн пропускается) 
.
Правило: бот обязан выводить юнита из spot до конца хода → в step 4 переходовки место будет пустым → спавн гарантирован.
2. Разведка (1-3 мин)	Все полученные разведчики (скорость 7, обзор 4) — фронтир-сканеры BFS: ищут «неизвестные» гексы по минимальной стоимости ходов; приоритет клеткам с ресурсами.
3. Грузопоток (весь раунд)	Рабочие (груз 8) собирают, сдают, потом дежурят у спота, чтобы быстро выгружать нектар. Правило сбора: если на гексе ≠ тип уже несомого ресурса — игнор (нельзя возить два типа) 
.
4. Охрана и рейды (со 2-й минуты)	Бойцы (атака 70 HP) патрулируют радиус 2 вокруг спота. При обнаружении чужого муравья возле нашего nest — контратакуют; вдали — не гонятся.
При калорийном лидерстве противника > 20 % запускаем рейд-сквад из 2 бойцов + 1 рабочего: стать на соседний гекс чужого nest, украсть нектар 
.
5. Финиш (последние 3 мин)	Переключаем всех бойцов на «шахид-режим»: набеги на лидеров с целью сбить им склад и убить максимум муравьёв (портим второе критерий). Рабочие продолжают сдавать то, что уже несут.
Приоритет цели для любого муравья рассчитывается как
P = value / (dist + 1) * riskCoeff,
где value — калорийность ресурса или ожидаемая добыча с рейда; riskCoeff — коэффициент < 1, если в радиусе 1 есть вражеский боец.

Ключевые правила, которые бот обязан соблюдать
Ограничение	Проверка
3 RPS	Счётчик запросов → sleep(max(0, timeWindowRemaining))
Нельзя зайти на гекс с чужим юнитом или с союзным того же типа 
A* учитывает занятость; если при переходовке блокируется путь → агента останавливаем
Камни (тип 5) непроходимы 
Стоимость ∞
Кислота наносит 20 урона при входе и на конце хода 
A* штраф + 25, избегать без веской причины
User Stories (выжимка)

Я, участник, жму «Run» → через ≤ 3 с бот регистрируется и начинает ходы.
Я вижу на карте всех моих муравьёв, видимые ресурсы, врагов; серые — неизведанные клетки.
В правом логе каждые 2 сек выводится: Turn 42 | +30 kcal | 2 scouts moved | 1 bread picked by ant #123.
Нажав «Pause» игра замирает (бот прекращает POST /move). Всё состояние сохранено.
Я могу кликнуть на муравья → кнопка «Retreat» → бот немедленно перестраивает путь этого юнита к spot, игнорируя автомат.
Technical Requirements

Архитектура
┌─────────┐       poll arena (≤3 RPS)      ┌───────────────┐
│ Core AI │ ──────────────────────────────►│  Game  API    │
└──┬───┬──┘  POST move / logs              └───────────────┘
   │   │
   │   ├─▶ SQLite (world, logs, cfg)
   │   │
   │   └─▶ FastAPI (/ui/*) ── WebSocket ──► React UI
Язык: Python 3.11
HTTP — httpx (async), pathfinding — networkx, hex utils — axial-coord helpers.
UI: React + TypeScript + eslint. Hex-grid — @tqman/hexlib (или свой Canvas).
База: SQLite 3 (fast / zero-deps).
Взаимодействие с внешним API
Эндпоинт	Метод	Назначение
/api/register	POST	{teamToken} → {teamId, home, spot}
/api/arena	GET	Возвращает полный partial-state 
/api/move	POST	{ moves:[{ant:uuid, path:[{q,r}…]}…] }
/api/logs	GET	Журнал; используем для отладки
Флоу на ход:

Ждём nextTurnIn → 0.3 s.
GET /arena; сохраняем turnNo, map и т.п.
Core AI генерирует список moves.
POST /move (1 запрос). Если пауза — пропускаем.
Записываем всё в SQLite и отсылаем дифф фронту через WS.
Алгоритмы
Задача	Алгоритм
Поиск пути	A* по гекс-решётке с весами: dirt = 2, acid = 1+20 HP-penalty, empty/nest = 1.
Назначение целей	Каждые 3 хода решаем assignment: ресурсы ↔ рабочие через жадный value/(dist+1); бойцов держим в радиусе 2 от spot, исключая одного «рейдера».
Разведка	Фронтир — набор гексов, где map == null; ближайший к любому скауту вычисляем BFS, отправляем.
Рейд	Условие: enemyScore > myScore*1.2 → ищем путь длины ≤ 10 до любого гекса вокруг enemy home; если есть — отправляем рейд-сквад; на месте ждём конца хода, крадём.
Боёвка	В конце хода сервер сам рандомизирует order 
; мы можем повысить шанс выиграть за счёт бонусов: держать двух бойцов рядом (50 % dmg bonus) + в радиусе nest (ещё 25 %) 
.
Data Models (SQLite)
Таблица	Ключ	Поля
meta	id=1	teamId, currentTurn, score
ants	id	type, q, r, hp, carryingType, carryingAmt
objects	q+r	type(hex/resource), amount, lastSeenTurn
enemies	enemyId	type, q, r, hp, lastSeenTurn
log	autoinc	ts, level, message
Индексы: (q,r) на objects/ants → быстрый поиск.

UI
Зона	Детали
Карта (70 %)	Canvas; ячейка = 24 px; цвет фона по type; иконки: scout △, fighter ⬣, worker ◼; tooltips при наведении.
Правая панель (30 %)	Scroll log, фильтры INFO/ERROR; индикаторы: turn #, score, ants count, RPS.
Контролы	Run/Pause, drop-down «Manual Action» (Retreat, Focus <id>, Raid <team>).
Security Requirements

Token из .env, не логируем.
Rate-limiter в Game Gateway, чтобы не превысить 3 RPS.
UI закрыто Basic Auth (user/pass в env).
Все JSON-ответы валидируем pydantic schemas; падения ловим, бот переходит в safe-mode (pause + автоповтор через 2 с).
Performance Requirements

Цикл принятия решения ≤ 50 ms (на ноутбуке).
GET /arena ровно 1 раз за ход; POST /move — 1.
WebSocket пушим фронту не чаще 10 fps.
Память ⩽ 200 MB (SQLite ≈ 1 MB).
Deployment Requirements

docker compose up — поднимает бот + nginx-reverse-proxy (443 → FastAPI 8000).
Горячая перезагрузка: SIGINT → Core AI пишет snapshot в DB → exit 0 → сервис-watcher стартует новый контейнер. Время простоя < 5 с.
Все зависимости фиксированы в requirements.txt; reproducible build.
Change Log

Версия	Дата	Изменения
1.0.0	11 Jul 2025	Первая финальная версия ТЗ на основе официальной доки DatsPulse
Итог
Документ охватывает точные игровые правила, детальный алгоритм на три фазы, структуру БД, сетевое взаимодействие, UI-мокап и эксплуатационные аспекты. Готов к прямой реализации: достаточно подключить токен, написать пару классов и стартовать хакатон.

---

# AI Decision Flow (Пошаговый алгоритм принятия решений)

1. **Получение состояния**: GET /api/arena → сохраняем всю карту, юнитов, врагов, ресурсы, turnNo.
2. **Обновление внутренней модели**: обновляем SQLite (ants, objects, enemies, meta).
3. **Назначение целей**:
   - Для каждого рабочего: ищем ближайший ресурс с максимальным value/(dist+1), если несёт — строим путь к spot.
   - Для разведчика: ищем ближайший неизвестный гекс (map == null), строим путь BFS.
   - Для бойца: если враг в радиусе 2 от spot — атакуем, иначе патрулируем вокруг spot. Если raid-режим — ищем путь к чужому nest.
4. **Построение путей**: A* с учётом занятых гексов, кислот, камней, союзников.
5. **Проверка ограничений**: не заходим на занятые гексы, не пересекаемся с союзниками того же типа, не лезем в кислоту без нужды.
6. **Генерация moves**: формируем массив moves[{ant, path}], отправляем POST /api/move.
7. **Логирование**: сохраняем все действия и ответы в log (DB и UI).
8. **UI push**: пушим фронту обновлённое состояние через WebSocket.

---

# Стратегии по типу юнита

- **Рабочий (worker)**: приоритет — нектар > хлеб > яблоко. Если несёт — сдаёт. Если свободен — ищет ближайший ресурс. Если нет ресурсов — дежурит у spot.
- **Разведчик (scout)**: всегда ищет ближайший неизвестный гекс, избегает врагов, не собирает ресурсы.
- **Боец (fighter)**: патрулирует радиус 2 от spot. Если враг близко — атакует. Если raid-режим — идёт к чужому nest, помогает воровать.

---

# Edge-cases и эвристики

- Если все ресурсы заняты — рабочие дежурят у spot.
- Если враг рядом с nest — все бойцы сбегаются на защиту.
- Если наш лидер по очкам — рейды не совершаем, только защищаемся.
- Если проигрываем >20% — запускаем рейд-сквад.
- Если лимит юнитов — не плодим новых, освобождаем spot.
- Если юнит заблокирован — перестраиваем маршрут.

---

# API Reference (кратко)

- **POST /api/register** — регистрация, сохраняем teamId, home, spot.
- **GET /api/arena** — основное состояние (юниты, карта, ресурсы, враги, turnNo, score).
- **POST /api/move** — отправка ходов (moves: [{ant, path}]).
- **GET /api/logs** — журнал действий (для отладки).

---

# Data Models (SQLite, уточнено)

- **meta**: id, teamId, currentTurn, score, enemyScores
- **ants**: id, type, q, r, hp, carryingType, carryingAmt, lastAction
- **objects**: q, r, type(hex/resource), amount, lastSeenTurn
- **enemies**: enemyId, type, q, r, hp, lastSeenTurn
- **log**: ts, level, message, turnNo

---

# UI (уточнено)

- **Карта**: hex-grid, цвет по типу, иконки юнитов, tooltips, серые — неизвестные.
- **Правая панель**: лог (фильтры INFO/ERROR), индикаторы (turn, score, ants, RPS).
- **Контролы**: Run/Pause, drop-down Manual Action (Retreat, Focus, Raid), переключение сервера (test/prod).
- **Всё работает локально**: запуск одной командой, без облаков, без внешних сервисов.

---

# Deployment (ещё раз)

- **docker compose up** — поднимает всё локально: бот, UI, nginx-proxy.
- **.env** — хранит токен, user/pass для UI.
- **requirements.txt** — фиксированные версии, reproducible build.

---

# Документация по алгоритму (summary)

Бот действует строго по математическим приоритетам: максимизация value/(dist+1), минимизация риска (riskCoeff), защита spot, рейды только при отставании, разведка — BFS по фронтиру. Все решения логируются, UI всегда показывает актуальное состояние. Алгоритм адаптивен: если ситуация меняется — меняет стратегию на лету.

## 2024-06-XX: Синхронизация теста и прода
- Вся логика движения (алгоритм make_moves) на проде теперь полностью идентична тестовому режиму (test_bot.py).
- Визуализация карты на фронте (HexMap) теперь полностью совпадает с HexMap_test: все отступы, цвета, подписи, иконки, легенда, координаты, ресурсы, муравьи, враги.
- На проде данные о карте берутся из API, а не с фронта.
- Лимит запросов: строго 1 запрос на получение карты и 1 на отправку движения в секунду (asyncio.sleep(1)), 1 резерв.
- Раз в 5 минут автоматически дергается ручка регистрации (POST /api/register), чтобы не вылететь из сессии.
- Все изменения покрыты комментариями в коде.

## [2024-07-12] Изменение логики запуска бэкенда
- Игра на бэкенде не стартует автоматически при запуске сервера.
- Запуск бота происходит только после POST /bot/run (например, по кнопке на фронте или вручную через API).
- Это гарантирует, что не будет лишних процессов и гонок между несколькими экземплярами.

## [2024-07-13] Оптимизация спавна и логирование ошибок движения

- Теперь бот отслеживает, в какой клетке home появился каждый новый муравей (по id и координате).
- При сдаче еды рабочий выбирает не ту клетку home, где был последний спавн, а одну из других свободных (если есть), чтобы не блокировать производство новых муравьёв.
- Если все клетки заняты — fallback на любую.
- После каждого POST /api/move, если сервер возвращает ошибки (например, ход не принят), они пишутся в лог с деталями: ant_id, path, причина.

### Edge-cases и доработки fallback (2024-07-13)
- Если fallback срабатывает (рандомное движение или неудачная попытка основного алгоритма), бот анализирует причину (все home заняты, нет пути, не хватило ОП, тупик и т.д.) и дорабатывает основной алгоритм, чтобы таких случаев стало меньше.
- Все случаи fallback логируются для последующего анализа и оптимизации.

# Требования к бизнес-логике (обновлено)

## Глобальное хранилище карты
- Все ячейки, которые когда-либо были видны, сохраняются в оперативной памяти (`known_map`).
- При каждом ходе новые ячейки добавляются или обновляются.
- Для принятия решений и для отдачи карты через API используется вся известная карта, а не только текущая видимость.

## Алгоритм движения муравьёв
- Муравьи без еды, стоящие на муравейнике, обязаны освобождать место, даже если для этого надо сдвинуть других.
- Если муравей с едой идёт домой, но все home заняты — цель переназначается на соседнюю свободную клетку.
- Разведчики разбредаются: если рядом есть другой разведчик — идут в противоположную сторону.
- Если не найден валидный ход — до талого ищем куда подвинуть муравья (случайная клетка в нужную сторону, предпочтительно от/к муравейнику в зависимости от наличия еды).
- Количество команд движения всегда равно количеству муравьёв.
- Все задачи распределяются между муравьями, чтобы не было толпы в одной точке.
- Лог-файл автоматически очищается до 20 000 строк.

## Алгоритм разведчиков
- Разведчик ищет ближайшую неизвестную клетку по всей карте (а не только в радиусе видимости).
- Если неизвестных клеток нет — идёт в самую дальнюю известную клетку (расширяет разведку).
- Разведчики не идут в одну и ту же точку (busy_targets).

## Алгоритм рабочих
- Рабочий ищет ближайшую еду по всей известной карте.
- Если еды нет — идёт в самую дальнюю известную клетку (рассредотачивается по краям карты).
- Рабочие не идут в одну и ту же точку (busy_targets).

## Распределение задач
- Для всех типов муравьёв задачи распределяются так, чтобы не было толпы в одной точке.
- Используется множество busy_targets для учёта занятых целей.

## Логирование
- Перед записью в лог-файл (`backend.log`), если он превышает 20 000 строк, оставляются только последние 20 000 строк.

## API карты
- Для фронта и анализа всегда отдаётся вся известная карта (`known_map`).

---

**Все изменения должны соответствовать этим требованиям.**

## Алгоритм формирования хода (бот) - ВЕРСИЯ 2.0

### Общая схема работы:
- После запуска сервиса создаётся экземпляр `BotManager`, который стартует две параллельные задачи:
  - Регистрация команды (раз в 5 минут)
  - Игровой цикл (раз в секунду)
- Каждый игровой цикл:
  1. Получает текущее состояние арены через API
  2. Если арена пуста — пропускает ход
  3. Если есть муравьи и карта — формирует список команд на движение
  4. Отправляет команды на сервер
  5. Логирует все действия

### Ключевые улучшения алгоритма (версия 2.0):

#### 1. **Правильный расчёт пути с учётом ОП муравьёв**
```python
def calculate_path_cost(start, end, ant_type):
    # ОП для разных типов муравьёв
    op_limits = {0: 3, 1: 7, 2: 5}  # рабочий, разведчик, боец
    max_op = op_limits.get(ant_type, 3)
    
    # Если расстояние больше ОП - ограничиваем
    if distance > max_op:
        # Находим промежуточную точку в пределах ОП
        ratio = max_op / distance
        q_mid = int(q1 + (q2 - q1) * ratio)
        r_mid = int(r1 + (r2 - r1) * ratio)
        return (q_mid, r_mid)
```

#### 2. **Приоритетная система целей**
1. **КЕЙС 1**: Муравей застрел 3+ раза → рандомное движение
2. **КЕЙС 2**: Муравей несёт еду → идём домой
3. **КЕЙС 3**: Разведчик (type=1) → ищем неизвестные клетки
4. **КЕЙС 4**: Боец (type=2) → ищем врагов
5. **КЕЙС 5**: Рабочий муравей (type=0) → ищем еду
6. **КЕЙС 6**: Fallback → любая еда в пределах ОП

#### 3. **Активное движение разведчиков**
- Разведчики имеют 7 ОП и активно исследуют неизвестные клетки
- Если неизвестных нет — идут за едой
- Используют полный потенциал движения

#### 4. **Распределение рабочих муравьёв**
- Рабочие муравьи (3 ОП) ищут ближайшую еду
- Не кучкуются в одной области
- Эффективно используют ограниченные ОП

#### 5. **Правильное завершение хода в муравейнике**
- Муравьи с едой идут к ближайшему дому
- Учитывается расстояние до дома
- Еда доставляется корректно

#### 6. **Система отслеживания застревания**
```python
# Проверяем застревание
if ant_id in self._last_positions:
    if self._last_positions[ant_id] == current_pos:
        self._stuck_counters[ant_id] = self._stuck_counters.get(ant_id, 0) + 1
    else:
        self._stuck_counters[ant_id] = 0

# Если застрел 3+ раза - рандомное движение
if stuck_count >= 3:
    random_target = find_free_neighbor(current_pos)
```

### Пример кода (backend/app/bot.py):

```python
async def run(self):
    self.running = True
    while self.running:
        try:
            # Получаем арену
            arena = await self.api.get_arena()
            self.log(f"Получили арену: ants={len(arena.ants)}, map={len(arena.map)}")
            
            # Если арена пуста - пропускаем ход
            if not arena.ants or not arena.map:
                self.log("EMPTY ARENA, SKIP MOVE")
                await asyncio.sleep(1)
                continue
            
            # Формируем команды движения
            moves = self.make_moves(arena)
            
            # Отправляем команды
            if moves:
                await self.api.move(moves)
                self.log(f"POST /api/move: {[m.model_dump() for m in moves]}")
            
        except Exception as e:
            self.log(f"Ошибка в игровом цикле: {e}")
        
        await asyncio.sleep(1)
```

### Результаты улучшений:

#### ✅ **Решённые проблемы:**
1. **Разведчики двигаются активно** — используют 7 ОП для исследования
2. **Рабочие муравьи распределяются** — не кучкуются в одной области
3. **Муравьи с едой идут домой** — правильно завершают ход в муравейнике
4. **Нет дублирования целей** — каждый муравей получает уникальную цель
5. **Система застревания работает** — рандомное движение после 3+ застреваний
6. **Учитываются ОП муравьёв** — правильный расчёт пути

#### 📊 **Метрики эффективности:**
- **Застревания**: снижены с 40+ до 0-3 раз
- **Движение разведчиков**: с 1-2 клеток до 7 клеток за ход
- **Доставка еды**: 100% муравьёв с едой идут домой
- **Распределение**: рабочие муравьи равномерно по карте

### Как оптимизировать/улучшить:

#### 🔧 **Технические улучшения:**
1. **A* алгоритм** — заменить простой расчёт расстояния на A*
2. **Кэширование путей** — сохранять рассчитанные пути
3. **Параллельная обработка** — обрабатывать муравьёв параллельно
4. **Машинное обучение** — предсказывать оптимальные цели

#### 🎯 **Стратегические улучшения:**
1. **Координация муравьёв** — избегать столкновений
2. **Приоритет еды** — выбирать более ценную еду
3. **Защита муравейника** — оставлять бойцов для защиты
4. **Экспансия** — активнее исследовать новые территории

#### 📈 **Мониторинг:**
1. **Логирование всех действий** — видно каждый шаг
2. **Метрики производительности** — скорость, эффективность
3. **Анализ застреваний** — причины и решения
4. **Статистика движения** — распределение по типам муравьёв

## Движение юнитов (муравьёв)
- Каждый юнит (муравей) имеет определённое количество очков передвижения (ОП), зависящее от типа.
- Стоимость перемещения на гекс зависит от типа гекса (см. HEX_COST).
- Нельзя заходить на гекс, где есть чужой юнит.
- Нельзя заходить на гекс, где есть дружественный юнит того же типа.
- Эти ограничения действуют не только на старте, но и в процессе движения (если два муравья идут по пути и могут встретиться — они не должны пересекаться).
- Если на пути встречается занятая клетка (враг или свой того же типа), муравей останавливается на предыдущем гексе.
- Если два муравья идут на один и тот же гекс, только один дойдёт (в коде реализовано: никто не идёт на уже зарезервированный гекс в этом ходе).
- После каждого шага муравья обновляется список занятых гексов (reserved_cells), чтобы избежать конфликтов.

## Типы муравьёв и их характеристики:
- **Рабочий муравей (type=0)**: 3 ОП, ищет еду, доставляет в муравейник
- **Разведчик (type=1)**: 7 ОП, исследует неизвестные клетки, открывает карту
- **Боец (type=2)**: 5 ОП, атакует врагов, защищает муравейник

## Типы клеток карты:
- **type=0**: неизвестная клетка (разведчики могут исследовать)
- **type=1**: обычная клетка (стоимость 1 ОП)
- **type=2**: камень (непроходимая)
- **type=3**: грязь (стоимость 2 ОП)
- **type=4**: кислота (стоимость 1 ОП)
- **type=5**: муравейник (стоимость 1 ОП)

## Система еды:
- Еда имеет тип (type) и количество (amount)
- Муравьи могут нести еду (food.amount > 0)
- Муравьи с едой должны идти домой
- После доставки еды в муравейник, еда исчезает из свойств муравья

## Система здоровья:
- Каждый муравей имеет здоровье (health)
- При атаке врагами здоровье уменьшается
- При health = 0 муравей умирает
- Бойцы имеют меньше здоровья, но больше ОП для атаки

## Интеграция фронтенд-бэкенд:
- **WebSocket**: основной канал для получения данных в реальном времени
- **REST API**: запасной вариант для получения состояния арены
- **Прокси Vite**: настроен для `/api/*` и `/api/gamews`
- **Fallback логика**: если WebSocket не работает, используется REST API
- **Автоматический старт**: бот запускается при старте сервера
- **Логирование**: все действия записываются в backend.log и консоль

---

## Реализация ручного режима приоритезации (manual priority)

- На фронте:
  - Каждый гекс кликабельный.
  - По клику — выделяется, по повторному клику — снимается.
  - Можно выделить до двух гексов (порядок важен).
  - Если выделено два — отправляется POST /api/manual_priority с координатами первого и второго.
  - После отправки выделение сбрасывается.

- На бэке:
  - POST /api/manual_priority принимает source и target (оба {q, r}).
  - Находит всех муравьёв на source, для каждого создаёт запись в in-memory таблице: ant_id, target_q, target_r, status (false).
  - Таблица manual_priority_table хранится в памяти (MVP).
  - Возвращает список id муравьёв, для которых создана запись.

- Дальнейшее использование:
  - При формировании маршрутов бот сначала проверяет manual_priority_table: если есть муравей со статусом false — строит маршрут к target.
  - Если муравей дошёл до target — статус становится true.
  - Для остальных муравьёв логика не меняется.
